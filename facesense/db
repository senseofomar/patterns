Fake Code Blueprint
===================

(High-Level Purpose)

This file is the DATABASE ADAPTER for FaceSense.

It owns:
- database connections
- session lifecycle
- emotion event persistence

It does NOT:
- know about cameras
- know about ML
- know about UI

It is the single source of truth
for writing system state to MySQL.
```

---

## Fake Code Blueprint (Structural View)

```
function get_connection():
    open and return new database connection


function create_session(name):

    open connection
    deactivate any existing active sessions
    insert new session row
    commit
    close connection
    return session id


function end_active_session():

    open connection
    mark active session as inactive
    set end_time
    commit
    close connection


function get_active_session():

    open connection
    query most recent active session
    close connection
    return row or None


function log_emotion(expression, confidence, bbox, session_ref_id):

    try:
        open connection
        unpack bounding box
        normalize confidence

        if session id not provided:
            fetch active session
            use its id if exists

        insert emotion log row
        commit
        close connection

    except error:
        print error
```

---

## Flow in Simple English (NO SKIPPED STEPS)

This file manages **persistent state**.

Whenever something needs to be stored,
this file is involved.

### Session lifecycle:

When a new session starts:

* all previous sessions are forcefully deactivated
* a new session row is inserted
* its ID becomes the reference point for logs

When a session ends:

* the active session is marked inactive
* an end timestamp is recorded

When someone asks:
“Is there an active session?”

* the database is queried
* the most recent active session is returned

### Emotion logging:

When an emotion event occurs:

A database connection is opened.

The face bounding box is unpacked
into individual numeric fields.

If no session ID was provided:

* the system attempts to find an active session
* if none exists, logs are still written with NULL session

A row is inserted into the emotion log table.

Changes are committed.

The connection is closed.

If anything fails:

* the error is printed
* the live system continues running

No crashes.
No silent failures.

---

## ENGINEERING PATTERNS (DETAILED, NO SHORTCUTS)

### ✔ Pattern #1 — CONNECTION FACTORY PATTERN

`get_connection()` creates a **new connection every time**.

This is intentional.

Database connections are:

* external resources
* stateful
* failure-prone

The universal pattern:

```
def get_connection():
    return connect(...)
```

Used in:

* web backends
* ETL pipelines
* background workers

Do NOT share raw connections globally.

---

### ✔ Pattern #2 — RESOURCE ACQUISITION → USE → RELEASE

Every DB function follows:

```
open connection
create cursor
execute queries
commit if needed
close connection
```

This pattern is sacred.

Used for:

* DB connections
* files
* sockets
* locks

Violating this causes:

* leaks
* deadlocks
* mysterious failures

---

### ✔ Pattern #3 — SESSION AS A FIRST-CLASS ENTITY

Sessions are explicit rows in the database.

They are not:

* global variables
* in-memory flags
* UI state

This allows:

* crash recovery
* auditing
* multi-process safety

Session management belongs in storage,
not in UI code.

---

### ✔ Pattern #4 — FAIL-SAFE SESSION RESET

Before creating a new session:
all existing sessions are deactivated.

Why?

Because:

* crashes happen
* processes die
* cleanup may not run

This ensures:

> at most one active session exists

This is defensive engineering.

---

### ✔ Pattern #5 — PARAMETERIZED QUERY PATTERN

All SQL uses placeholders:

```
VALUES (%s, %s, ...)
cursor.execute(query, values)
```

This prevents:

* SQL injection
* quoting bugs
* type mismatches

This is non-negotiable.

---

### ✔ Pattern #6 — STRUCTURED DATA FLATTENING

Bounding boxes arrive as a tuple.

Databases store flat fields.

So you:

```
(x1, y1, x2, y2) = bbox
```

This pattern appears in:

* analytics
* logging
* telemetry
* tracking systems

Structured in code.
Flat in storage.

---

### ✔ Pattern #7 — OPTIONAL CONTEXT RESOLUTION

`log_emotion` does not assume
a session is always provided.

Instead:

* it tries to resolve context itself
* falls back gracefully if none exists

This makes the function:

* more reusable
* safer
* decoupled from callers

---

### ✔ Pattern #8 — FAIL-SOFT DATABASE LOGGING

Database writes should NEVER crash live systems.

So the rule is:

```
try:
    write to DB
except:
    log error
    continue system
```

This prioritizes:

* uptime
* user experience
* observability

Over:

* perfect data completeness

---

### ✔ Pattern #9 — STORAGE ADAPTER PATTERN

This file is the ONLY place that knows:

* table names
* column names
* SQL syntax

Every other part of the system talks in:

* emotions
* confidence
* bounding boxes

Never leak SQL outward.

---

## Prerequisites You Must Know (STRICT)

### A. SQL Basics

INSERT, UPDATE, SELECT.

### B. Parameterized Queries

Never string-format SQL.

### C. Transactions

commit() persists changes.

### D. DB Connections Are Expensive

Open late, close early.

### E. Storage ≠ Business Logic

DB files store facts.
They do not make decisions.

---

## Final Mental Model (IMPORTANT)

This file is **memory**.

Everything else is perception.

Cameras see.
Models infer.
UI displays.

This file **remembers**.

---
